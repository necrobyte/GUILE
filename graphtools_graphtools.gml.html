<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>graphtools/graphtools.gml - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/necrobyte/GUILE" target="_blank" class="menu-item" id="website_link" >GUILE</a></h2><h3>Classes</h3><ul><li class="level-hide"><a href="module-arraytools-Array.html">Array</a></li><li class="level-hide"><a href="module-graphtools.Graph.html">Graph</a></li><li class="level-hide"><a href="module-graphtools.GraphStructs.html">GraphStructs</a></li><li class="level-hide"><a href="module-itertools-Iterator.html">Iterator</a></li><li class="level-hide"><a href="module-itertools.IteratorDict.html">IteratorDict</a></li><li class="level-hide"><a href="module-itertools-IteratorCollection.html">IteratorCollection</a></li><li class="level-hide"><a href="module-itertools-Range.html">Range</a></li><li class="level-hide"><a href="module-itertools-Random.html">Random</a></li></ul><h3>Modules</h3><ul><li><a href="module-arraytools.html">arraytools</a><ul class='methods'><li data-type='method'><a href="module-arraytools.html#~array_append">array_append</a></li><li data-type='method'><a href="module-arraytools.html#~array_bisect_left">array_bisect_left</a></li><li data-type='method'><a href="module-arraytools.html#~array_bisect_right">array_bisect_right</a></li><li data-type='method'><a href="module-arraytools.html#~array_clear">array_clear</a></li><li data-type='method'><a href="module-arraytools.html#~array_clone">array_clone</a></li><li data-type='method'><a href="module-arraytools.html#~array_concat">array_concat</a></li><li data-type='method'><a href="module-arraytools.html#~array_count">array_count</a></li><li data-type='method'><a href="module-arraytools.html#~array_delete">array_delete</a></li><li data-type='method'><a href="module-arraytools.html#~array_extend">array_extend</a></li><li data-type='method'><a href="module-arraytools.html#~array_flat">array_flat</a></li><li data-type='method'><a href="module-arraytools.html#~array_index">array_index</a></li><li data-type='method'><a href="module-arraytools.html#~array_insert">array_insert</a></li><li data-type='method'><a href="module-arraytools.html#~array_map">array_map</a></li><li data-type='method'><a href="module-arraytools.html#~array_pop">array_pop</a></li><li data-type='method'><a href="module-arraytools.html#~array_remove">array_remove</a></li><li data-type='method'><a href="module-arraytools.html#~array_reshape">array_reshape</a></li><li data-type='method'><a href="module-arraytools.html#~array_reverse">array_reverse</a></li><li data-type='method'><a href="module-arraytools.html#~array_shape">array_shape</a></li><li data-type='method'><a href="module-arraytools.html#~array_slice">array_slice</a></li><li data-type='method'><a href="module-arraytools.html#~array_swap">array_swap</a></li><li data-type='method'><a href="module-arraytools.html#~array_sort">array_sort</a></li><li data-type='method'><a href="module-arraytools.html#~array_qsort">array_qsort</a></li></ul></li><li><a href="module-graphtools.html">graphtools</a><ul class='methods'><li data-type='method'><a href="module-graphtools.html#~graph_complete">graph_complete</a></li><li data-type='method'><a href="module-graphtools.html#~graph_cycle">graph_cycle</a></li><li data-type='method'><a href="module-graphtools.html#~graph_empty">graph_empty</a></li><li data-type='method'><a href="module-graphtools.html#~graph_path">graph_path</a></li><li data-type='method'><a href="module-graphtools.html#~graph_star">graph_star</a></li></ul></li><li><a href="module-itertools.html">itertools</a><ul class='methods'><li data-type='method'><a href="module-itertools.html#~__iter_dict">__iter_dict</a></li><li data-type='method'><a href="module-itertools.html#~__iter_collection">__iter_collection</a></li><li data-type='method'><a href="module-itertools.html#~_tee">_tee</a></li><li data-type='method'><a href="module-itertools.html#~_range">_range</a></li><li data-type='method'><a href="module-itertools.html#~_arange">_arange</a></li><li data-type='method'><a href="module-itertools.html#~_irange">_irange</a></li><li data-type='method'><a href="module-itertools.html#~range_prod">range_prod</a></li><li data-type='method'><a href="module-itertools.html#~_random">_random</a></li><li data-type='method'><a href="module-itertools.html#~ds_list_iter">ds_list_iter</a></li><li data-type='method'><a href="module-itertools.html#~ds_stack_iter">ds_stack_iter</a></li><li data-type='method'><a href="module-itertools.html#~ds_queue_iter">ds_queue_iter</a></li><li data-type='method'><a href="module-itertools.html#~ds_map_iter">ds_map_iter</a></li><li data-type='method'><a href="module-itertools.html#~ds_priority_max_iter">ds_priority_max_iter</a></li><li data-type='method'><a href="module-itertools.html#~ds_priority_min_iter">ds_priority_min_iter</a></li><li data-type='method'><a href="module-itertools.html#~is_iterable">is_iterable</a></li><li data-type='method'><a href="module-itertools.html#~iter">iter</a></li><li data-type='method'><a href="module-itertools.html#~_accumulate">_accumulate</a></li><li data-type='method'><a href="module-itertools.html#~_chain">_chain</a></li><li data-type='method'><a href="module-itertools.html#~_chain_from_iterable">_chain_from_iterable</a></li><li data-type='method'><a href="module-itertools.html#~_compress">_compress</a></li><li data-type='method'><a href="module-itertools.html#~_count">_count</a></li><li data-type='method'><a href="module-itertools.html#~_cycle">_cycle</a></li><li data-type='method'><a href="module-itertools.html#~_drop">_drop</a></li><li data-type='method'><a href="module-itertools.html#~_dropwhile">_dropwhile</a></li><li data-type='method'><a href="module-itertools.html#~_enumerate">_enumerate</a></li><li data-type='method'><a href="module-itertools.html#~_filter">_filter</a></li><li data-type='method'><a href="module-itertools.html#~_filter_false">_filter_false</a></li><li data-type='method'><a href="module-itertools.html#~_group_by">_group_by</a></li><li data-type='method'><a href="module-itertools.html#~_imap">_imap</a></li><li data-type='method'><a href="module-itertools.html#~_imap_from_iterable">_imap_from_iterable</a></li><li data-type='method'><a href="module-itertools.html#~_islice">_islice</a></li><li data-type='method'><a href="module-itertools.html#~_ndenumerate">_ndenumerate</a></li><li data-type='method'><a href="module-itertools.html#~_repeat">_repeat</a></li><li data-type='method'><a href="module-itertools.html#~_take">_take</a></li><li data-type='method'><a href="module-itertools.html#~_takewhile">_takewhile</a></li><li data-type='method'><a href="module-itertools.html#~_zip">_zip</a></li><li data-type='method'><a href="module-itertools.html#~_zip_longest">_zip_longest</a></li><li data-type='method'><a href="module-itertools.html#~_combinations">_combinations</a></li><li data-type='method'><a href="module-itertools.html#~_combinations_with_replacements">_combinations_with_replacements</a></li><li data-type='method'><a href="module-itertools.html#~_permutations">_permutations</a></li><li data-type='method'><a href="module-itertools.html#~_product">_product</a></li><li data-type='method'><a href="module-itertools.html#~_all">_all</a></li><li data-type='method'><a href="module-itertools.html#~_any">_any</a></li><li data-type='method'><a href="module-itertools.html#~_reduce">_reduce</a></li><li data-type='method'><a href="module-itertools.html#~_sorted">_sorted</a></li><li data-type='method'><a href="module-itertools.html#~_unique">_unique</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">graphtools/graphtools.gml</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/// @fileOverview classes and functions related to array handling
/// @module graphtools

#region Graph

/// @func Graph( )
/// @name Graph
/// @class
/// @memberof module:graphtools
///
/// @classdesc Generic graph
///
/// @arg {Bool} [directed=false]
///
/// @return {Graph} - Graph struct

function Graph( ) constructor {
	/// @member {Bool} directed
	/// @memberof Graph
	///
	/// @desc If true, Graph is directed
	directed = ( argument_count > 0 ) ? argument[ 0 ] : false;
	
	/// @member {StructMap} node
	/// @memberof Graph
	///
	/// @desc StructMap holding all nodes
	node = new StructMap();
	
	/// @member {StructMap} adj
	/// @memberof Graph
	///
	/// @desc StructMap holding all outgoing node-connection information
	adj = new StructMap();
	
	/// @member {StructMap} pred
	/// @memberof Graph
	///
	/// @desc StructMap holding all incoming node-connection information.
	pred = directed ? new StructMap() : adj;
	
	/*
		methods
	*/
	
	static __iter = function() {
		return node.items();
	}
	
	static to_string = function() {
		return "{ " + node.keys().to_string( ", " ) + " }";
	}
	
	/// @method add_edge
	/// @memberof Graph
	///
	/// @desc Add an edge between nodes a and b. If nodes are not in graph, nodes are added.
	///
	/// @arg {Any} a
	/// @arg {Any} b
	/// @arg {Number} [weight=1]
	/// @arg {Array} [attr] If attr is Struct, replaces current edge data with attr.
	
	static add_edge = function( a, b ) {
		var _weight = ( argument_count > 2 ) ? argument[ 2 ] : undefined;
		var _attr = ( argument_count > 3 ) ? argument[ 3 ] : undefined;
		
		if ( is_undefined( node.get( a ) ) ) {
			add_node( a );
		}
		
		if ( is_undefined( node.get( b ) ) ) {
			add_node( b );
		}
		
		var _adj = adj.get( a );
		var _pred = pred.get( b );
		
		var _edge = edge_create( a, b, _adj.get( b ), _weight, _attr );
		
		_adj.set( b, _edge );
		_pred.set( a, _edge );
	}
	
	/// @method add_edges_from
	/// @memberof Graph
	///
	/// @desc Add an edges from iterable. If nodes are not in graph, nodes are added.
	///
	/// @arg {Any} a
	/// @arg {Any} b
	/// @arg {Number} [weight=1]
	/// @arg {Array} [attr]
	
	static add_edges_from = function( _iterable ) {
		var _weight = ( argument_count > 2 ) ? argument[ 2 ] : undefined;
		var _attr = undefined;
		
		if ( is_array( _weight ) || is_struct( _weight ) ) {
			_attr = _weight;
			_weight = undefined;
		} else if ( argument_count > 3 ){
			_attr = argument[ 3 ];
			if ( is_struct( _attr ) ) {
				_attr = iter( _attr ).to_array();	
			}
		}
		
		var _iter = iter( _iterable );
				
		while ( !_iter.is_done() ) {
			var _edge = _iter.next();
			var n = array_length( _edge );
			add_edge( _edge[ 0 ], _edge[ 1 ], ( n > 2 ) ? _edge[ 2 ] : _weight, ( n > 3 ) ? _edge[ 3 ] : _attr );
		}
	}
	
	/// @method add_node
	/// @memberof Graph
	///
	/// @desc add node. If node exists, update attributes.
	///
	/// @arg {Any} node
	/// @arg {Array} [attr] [key, value] pairs. If attr is Struct, replaces current node data with attr.
	///
	/// @example
	/// g.add_node( 1, { text : "hello" } );
	///g.add_node( 2, [[ "text", "world" ]] );
	
	static add_node = function( _node ) {
		var _attr = ( argument_count > 1 ) ? argument[ 1 ] : undefined;
		
		var _old_node = node.get( _node );
		var _new_node = node_create( _node, _old_node, _attr );
		
		node.add( _node, _new_node );
				
		if ( is_undefined( _old_node ) ) {
			adj.add( _node, new StructMap() );
			
			if ( directed ) {
				pred.add( _node, new StructMap() );
			}
		}
	}
	
	/// @method add_nodes_from
	/// @memberof Graph
	///
	/// @desc Add nodes. If node exists, update attributes.
	///
	/// @arg {Iterable} iterable
	/// @arg {Array} [attr] [key, value] pairs
	
	static add_nodes_from = function ( _iterable ) {
		var _iter = iter( _iterable );
		var _attr = ( argument_count > 1 ) ? argument[ 1 ] : undefined;
		
		if ( is_struct( _attr ) ) {
			_attr = iter( _attr ).to_array();	
		}
		
		while ( !_iter.is_done() ) {
			var _node = _iter.next();
			if ( is_array( _node ) ) {
				add_node( _node[ 0 ], _node[ 1 ] );
			} else {
				add_node( _node, _attr );
			}
		}
	}
	
	/// @method adjacency
	/// @memberof Graph
	///
	/// @desc Returns an iterator over [ node, adjacency struct ] for all nodes
	///
	/// @return {IteratorDict}
	
	static adjacency = function() {
		var _iter = __iter_dict( adj, function() {
			return key_iter.next();
		}, function( _key ) {
			return data.get( _key ).items().to_struct();
		}, function() {
			return key_iter.is_done();
		} );
		
		_iter.key_iter = adj.keys();
		
		return _iter;
	}
	
	/// @method bfs_edges
	/// @memberof Graph
	///
	/// @desc Perform a breadth-first-search over the nodes of Graph and yield the edges in order.
	///
	/// @arg {Any} [source] starting node for breadth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Iterator} Yields edges in breadth-first-search order from source
	
	static bfs_edges = function( ) {
		var _iter = new Iterator( self, 
		function() {
			var _result = [ start, dest ];
			dest = undefined;
			
			return _result;
		}, function() {
			while( is_undefined( dest ) ) {
				while( is_undefined( start ) &amp;&amp; ( !nodes.is_done() ) ) {
					start = nodes.next();
					
					if ( ( variable_struct_exists( visited, start ) ) ) {
						start = undefined;
						continue;
					} else {
						variable_struct_set( visited, start, true );
						cache = [ [ start, depth_limit, data.neighbors( start ) ] ];
						index = 0;
						last = 0;
					}
				}
				
				if ( index > last ) {
					break;
				}
				
				var _element = cache[ index ];
				var _parent = _element[ 0 ];
				var _depth = _element[ 1 ];
				var _nodes = _element[ 2 ];
				
				while ( is_undefined( dest ) &amp;&amp; ( !_nodes.is_done() ) ) {
					dest = _nodes.next();
					
					if ( variable_struct_exists( visited, dest ) ) {
						dest = undefined;
					} else {
						start = _parent;
						variable_struct_set( visited, dest, true );
						
						if ( _depth > 1 ) {
							cache[ ++last ] = [ dest, _depth - 1, data.neighbors( dest ) ];
						}
						
						return false;
					}
				}
				
				if ( ++index > last ) {
					start = undefined;	
				}
			}
			
			return ( nodes.is_done() &amp;&amp; ( index > last ) );
		} );
		
		_iter.nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		_iter.depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		_iter.start = undefined;
		_iter.dest = undefined;
		_iter.visited = { };
		_iter.cache = [ ];
		_iter.index = 0;
		_iter.last = -1;
		
		return _iter;
	}
	
	/// @method bfs_nodes
	/// @memberof Graph
	///
	/// @desc Perform a breadth-first-search over the nodes of Graph and yield the nodes in order.
	///
	/// @arg {Any} [source] starting node for breadth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Iterator} Yields nodes in breadth-first-search order from source
	
	static bfs_nodes = function( ) {
		var _iter = new Iterator( self, 
		function() {
			var _result = dest;
			dest = undefined;
			
			return _result;
		}, function() {
			while( is_undefined( dest ) ) {
				while( is_undefined( start ) &amp;&amp; ( !nodes.is_done() ) ) {
					start = nodes.next();
					
					if ( ( variable_struct_exists( visited, start ) ) ) {
						start = undefined;
						continue;
					} else {
						variable_struct_set( visited, start, true );
						cache = [ [ start, depth_limit, data.neighbors( start ) ] ];
						index = 0;
						last = 0;
						dest = start;
						return false;
					}
				}
				
				if ( index > last ) {
					break;
				}
				
				var _element = cache[ index ];
				var _parent = _element[ 0 ];
				var _depth = _element[ 1 ];
				var _nodes = _element[ 2 ];
				
				while ( is_undefined( dest ) &amp;&amp; ( !_nodes.is_done() ) ) {
					dest = _nodes.next();
					
					if ( variable_struct_exists( visited, dest ) ) {
						dest = undefined;
					} else {
						start = _parent;
						variable_struct_set( visited, dest, true );
						
						if ( _depth > 1 ) {
							cache[ ++last ] = [ dest, _depth - 1, data.neighbors( dest ) ];
						}
						
						return false;
					}
				}
				
				if ( ++index > last ) {
					start = undefined;	
				}
			}
			
			return ( nodes.is_done() &amp;&amp; ( index > last ) );
		} );
		
		_iter.nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		_iter.depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		_iter.start = undefined;
		_iter.dest = undefined;
		_iter.visited = { };
		_iter.cache = [ ];
		_iter.index = 0;
		_iter.last = -1;
		
		return _iter;
	}
	
	/// @method bfs_predecessors
	/// @memberof Graph
	///
	/// @desc Returns struct of node predecessors in breadth-first-search from source.
	///
	/// @arg {Any} [source] starting node for breadth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Struct} Key is node, value is node predecessor
	
	static bfs_predecessors = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = { };
		
		var _iter = bfs_edges( _nodes, _depth_limit );
		
		while( !_iter.is_done() ) {
			var _item = _iter.next();
			variable_struct_set( _result, _item[ 1 ], _item[ 0 ] );
		}
		
		return _result;
	}
	
	/// @method bfs_successors
	/// @memberof Graph
	///
	/// @desc Returns struct of successors in breadth-first-search from source.
	///
	/// @arg {Any} [source] starting node for breadth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Struct} Key is node, value is array of node successors
	
	static bfs_successors = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = { };
		
		var _iter = bfs_edges( _nodes, _depth_limit );
		
		while( !_iter.is_done() ) {
			var _item = _iter.next();
			if ( variable_struct_exists( _result, _item[ 0 ] ) ) {
				var _value = variable_struct_get( _result, _item[ 0 ] );
				_value[ array_length( _value ) ] = _item[ 1 ];
				variable_struct_set( _result, _item[ 0 ], _value );
			} else {
				variable_struct_set( _result, _item[ 0 ], [ _item[ 1 ] ] );	
			}
		}
		
		return _result;
	}
	
	/// @method bfs_tree
	/// @memberof Graph
	///
	/// @desc returns directed subgraph build on edges from breadth-first search
	///
	/// @arg {Any} [source] starting node for breadth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Graph}
	
	static bfs_tree = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = graph_empty( _nodes, true );
		_result.add_edges_from( bfs_edges( _result.nodes(), _depth_limit ) );
		
		return _result;
	}
	
	/// @method clear
	/// @memberof Graph
	///
	/// @desc Remove all nodes and edges
		
	static clear = function() {
		node.clear();
		clear_edges();
	}
	
	/// @method clear_edges
	/// @memberof Graph
	///
	/// @desc Remove all edges leaving nodes untouched
	
	static clear_edges = function() {
		adj.clear();
		if ( directed ) {
			pred.clear();	
		}
	}
	
	/// @method copy
	/// @memberof Graph
	///
	/// @desc Returns copy of the graph
	///
	/// @arg {Bool} [deep=false] If false, node and edge data is referenced, not copied.
	///
	/// @return Graph
	
	static copy = function() {
		var _deep = ( argument_count > 0 ) ? argument[ 0 ] : false;
		
		return directed ? to_directed( _deep ) : to_undirected( _deep );
	}
	
	/// @method copy_methods
	/// @memberof Graph
	///
	/// @desc Copied node and edge specific methods into Graph
	///
	/// @arg {Graph} graph
	
	function copy_methods( _graph ) {
		_graph.edge_copy = edge_copy;
		_graph.edge_create = edge_create;
		_graph.edge_equal = edge_equal
		_graph.edge_weight = edge_weight;
		
		_graph.node_copy = node_copy;
		_graph.node_create = node_create;
		_graph.node_equal = node_equal;	
	}
	
	/// @method degree
	/// @memberof Graph
	///
	/// @desc Returns node degree in Graph. If node is iterable, return Iterator of pairs [ node, degree ];
	///
	/// @arg {Any} [node]
	///
	/// @return {Number}
	
	static degree = function( ) {
		if ( argument_count > 0 ) {
			var _node = argument[ 0 ];
			if ( is_iterable( _node ) ) {
				var _iter = __iter_dict( iter( _node ), function( ) {
					var _result = cache;
					cache = undefined;
					return _result;
				}, function( _key ) {
					return adj.get( _key ).size;
				}, function() {
					while ( is_undefined( cache ) &amp;&amp; ( !data.is_done() ) ) {
						cache = data.next();
						if ( is_undefined( adj.get( cache ) ) ) {
							cache = undefined;
						}
					}
					
					return is_undefined( cache );
				} );
						
				_iter.adj = adj;
				_iter.cache = undefined;
				
				return _iter;
			}
			
			var _adj = adj.get( _node );
			
			if ( is_undefined( _adj ) ) {
				throw "The node " + string( _node ) + " is not in the graph.";
			}
			
			return _adj.items().reduce( function( a, e ) { return a + edge_weight( e[ 1 ] ); }, 0 );
		} else {
			return number_of_nodes();	
		}
	}
	
	/// @method dfs_edges
	/// @memberof Graph
	///
	/// @desc Perform a depth-first-search over the nodes of Graph and yield the edges in order.
	///
	/// @arg {Any} [source] starting node for depth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Iterator} Yields edges in depth-first-search order from source
	
	static dfs_edges = function( ) {
		var _iter = new Iterator( self, 
		function() {
			var _result = [ start, dest ];
			dest = undefined;
			
			return _result;
		}, function() {
			while( is_undefined( dest ) ) {
				while( is_undefined( start ) &amp;&amp; ( !nodes.is_done() ) ) {
					start = nodes.next();
					
					if ( ( variable_struct_exists( visited, start ) ) ) {
						start = undefined;
						continue;
					} else {
						variable_struct_set( visited, start, true );
						cache = [ [ start, depth_limit, data.neighbors( start ) ] ];
						index = 0;
					}
				}
				
				if ( index &lt; 0 ) {
					break;
				}
				
				var _element = cache[ index ];
				var _parent = _element[ 0 ];
				var _depth = _element[ 1 ];
				var _nodes = _element[ 2 ];
				
				while ( is_undefined( dest ) &amp;&amp; ( !_nodes.is_done() ) ) {
					dest = _nodes.next();
					
					if ( variable_struct_exists( visited, dest ) ) {
						dest = undefined;
					} else {
						start = _parent;
						variable_struct_set( visited, dest, true );
						
						if ( _depth > 1 ) {
							cache[ ++index ] = [ dest, _depth - 1, data.neighbors( dest ) ];
						}
						
						return false;
					}
				}
				
				if ( --index &lt; 0 ) {
					start = undefined;	
				}
			}
			
			return ( nodes.is_done() &amp;&amp; ( index &lt; 0 ) );
		} );
		
		_iter.nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		_iter.depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		_iter.start = undefined;
		_iter.dest = undefined;
		_iter.visited = { };
		_iter.cache = [ ];
		_iter.index = -1;
		
		return _iter;
	}
	
	/// @method dfs_nodes
	/// @memberof Graph
	///
	/// @desc Perform a depth-first-search over the nodes of Graph and yield the nodes in order.
	///
	/// @arg {Any} [source] starting node for depth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Iterator} Yields nodes in depth-first-search order from source
	
	static dfs_nodes = function( ) {
		var _iter = new Iterator( self, 
		function() {
			var _result = dest;
			dest = undefined;
			
			return _result;
		}, function() {
			while( is_undefined( dest ) ) {
				while( is_undefined( start ) &amp;&amp; ( !nodes.is_done() ) ) {
					start = nodes.next();
					
					if ( ( variable_struct_exists( visited, start ) ) ) {
						start = undefined;
						continue;
					} else {
						variable_struct_set( visited, start, true );
						cache = [ [ start, depth_limit, data.neighbors( start ) ] ];
						index = 0;
						dest = start;
						return false;
					}
				}
				
				if ( index &lt; 0 ) {
					break;
				}
				
				var _element = cache[ index ];
				var _parent = _element[ 0 ];
				var _depth = _element[ 1 ];
				var _nodes = _element[ 2 ];
				
				while ( is_undefined( dest ) &amp;&amp; ( !_nodes.is_done() ) ) {
					dest = _nodes.next();
					
					if ( variable_struct_exists( visited, dest ) ) {
						dest = undefined;
					} else {
						start = _parent;
						variable_struct_set( visited, dest, true );
						
						if ( _depth > 1 ) {
							cache[ ++index ] = [ dest, _depth - 1, data.neighbors( dest ) ];
						}
						
						return false;
					}
				}
				
				if ( --index &lt; 0 ) {
					start = undefined;	
				}
			}
			
			return ( nodes.is_done() &amp;&amp; ( index &lt; 0 ) );
		} );
		
		_iter.nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		_iter.depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		_iter.start = undefined;
		_iter.dest = undefined;
		_iter.visited = { };
		_iter.cache = [ ];
		_iter.index = -1;
		
		return _iter;
	}
	
	/// @method dfs_predecessors
	/// @memberof Graph
	///
	/// @desc Returns struct of node predecessors in depth-first-search from source.
	///
	/// @arg {Any} [source] starting node for depth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Struct} Key is node, value is array of node predecessors
	
	static dfs_predecessors = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = { };
		
		var _iter = dfs_edges( _nodes, _depth_limit );
		
		while( !_iter.is_done() ) {
			var _item = _iter.next();
			variable_struct_set( _result, _item[ 1 ], _item[ 0 ] );
		}
		
		return _result;
	}
	
	/// @method dfs_successors
	/// @memberof Graph
	///
	/// @desc Returns struct of successors in depth-first-search from source.
	///
	/// @arg {Any} [source] starting node for depth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Struct} Key is node, value is node successor
	
	static dfs_successors = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = { };
		
		var _iter = dfs_edges( _nodes, _depth_limit );
		
		while( !_iter.is_done() ) {
			var _item = _iter.next();
			if ( variable_struct_exists( _result, _item[ 0 ] ) ) {
				var _value = variable_struct_get( _result, _item[ 0 ] );
				_value[ array_length( _value ) ] = _item[ 1 ];
				variable_struct_set( _result, _item[ 0 ], _value );
			} else {
				variable_struct_set( _result, _item[ 0 ], [ _item[ 1 ] ] );	
			}
		}
		
		return _result;
	}
	
	/// @method dfs_tree
	/// @memberof Graph
	///
	/// @desc returns directed subgraph build on edges from depth-first search
	///
	/// @arg {Any} [source] starting node for depth-first search
	/// @arg {Number} [depth] maximum search depth
	///
	/// @return {Graph}
	
	static dfs_tree = function() {
		var _nodes = ( argument_count > 0 ) ? iter( argument[ 0 ] ) : nodes();
		var _depth_limit = ( argument_count > 1 ) ? argument[ 1 ] : number_of_nodes();
		
		var _result = graph_empty( _nodes, true );
		_result.add_edges_from( dfs_edges( _result.nodes(), _depth_limit ) );
		
		return _result;
	}
	
	/// @method dijkstra
	/// @memberof Graph
	///
	/// @desc Find shortest weighted paths and lengths to a given set of destination nodes using Uses Dijkstra's algorithm.
	///
	/// @arg {Any} nodes
	/// @arg {Number} [cutoff=infinity] Depth to stop the search. Only return paths with length &lt;= cutoff
	///
	/// @return {Graph} Graph node is struct \{ dist, succ, depth \}
	///dist is total distance to destination node
	///succ is next node
	///depth is number of edges to destination node
	
	static dijkstra = function ( _nodes ) {
		var _cutoff = ( argument_count > 1 ) ? argument[ 1 ] : infinity;
		
		var _result = new Graph( );
		var _heap = ds_priority_create( );
		
		_result.add_nodes_from( _imap( function( _node, _heap ) {
			ds_priority_add( _heap, _node, 0 );
			return [ _node, { depth : 0, dist: 0, succ : undefined } ];
		}, get_from( _nodes ), _repeat( _heap ) ) );
		
		var _iter = ds_priority_min_iter( _heap );
		
		while( !_iter.is_done( ) ) {
			var _node = _iter.next();
			var _depth = _result.get( _node ).depth;
			
			var _predecessors = predecessors( _node );
				
			while( !_predecessors.is_done() ) {
				var _pred = _predecessors.next();
				var _dist = get_weight( _pred, _node );
				var _dist_cum = _dist + _result.get( _node ).dist;
					
				if ( _dist_cum &lt;= _cutoff ) {
					var _succ_node = _result.get( _pred );
					
					if ( is_undefined( _succ_node ) ) {
						_result.add_node( _pred, { depth : _depth + 1, dist : _dist_cum , succ: _node } );
						_result.add_edge( _node, _pred, _dist );
						ds_priority_add( _heap, _pred, _dist_cum );
					} else if ( ( _succ_node.dist > _dist_cum ) || ( ( _succ_node.dist > _dist_cum ) &amp;&amp; ( _succ_node.depth > _depth + 1 ) ) ){
						if ( !is_undefined( _succ_node.succ ) ) {
							_result.add_edge( _succ_node.succ, _pred, undefined );
						}
						
						_result.add_edge( _node, _pred, _dist );
						
						_succ_node.dist = _dist_cum;
						_succ_node.succ = _node;
						_succ_node.depth = _depth + 1;
						
						if ( !is_undefined( ds_priority_find_priority( _heap, _pred ) ) ) {
							ds_priority_change_priority( _heap, _pred, _dist_cum );
						}
					}	
				}
			}
		}
		
		ds_priority_destroy( _heap );
		
		return _result;
	}
	
	/// @method dijkstra_from
	/// @memberof Graph
	///
	/// @desc Find shortest weighted paths and lengths to a given set of source nodes using Uses Dijkstra's algorithm.
	///
	/// @arg {Any} nodes
	/// @arg {Number} [cutoff=infinity] Depth to stop the search. Only return paths with length &lt;= cutoff
	///
	/// @return {Graph} Graph node is struct \{ dist, pred, depth \}
	///dist is total distance to source node
	///pred is previous node
	///depth is number of edges to source node
	
	static dijkstra_from = function ( _nodes ) {
		var _cutoff = ( argument_count > 1 ) ? argument[ 1 ] : infinity;
		
		var _result = new Graph( );
		var _heap = ds_priority_create( );
		
		_result.add_nodes_from( _imap( function( _node, _heap ) {
			ds_priority_add( _heap, _node, 0 );
			return [ _node, { depth : 0, dist: 0, prev : undefined } ];
		}, get_from( _nodes ), _repeat( _heap ) ) );
		
		var _iter = ds_priority_min_iter( _heap );
		
		while( !_iter.is_done( ) ) {
			var _node = _iter.next();
			var _depth = _result.get( _node ).depth;
			
			var _successors = successors( _node );
				
			while( !_successors.is_done() ) {
				var _succ = _successors.next();
				var _dist = get_weight( _node, _succ );
				var _dist_cum = _dist + _result.get( _node ).dist;
					
				if ( _dist_cum &lt;= _cutoff ) {
					var _pred_node = _result.get( _succ );
					
					if ( is_undefined( _pred_node ) ) {
						_result.add_node( _succ, { depth : _depth + 1, dist : _dist_cum , prev: _node } );
						_result.add_edge( _node, _succ, _dist );
						ds_priority_add( _heap, _succ, _dist_cum );
					} else if ( ( _pred_node.dist > _dist_cum ) || ( ( _pred_node.dist > _dist_cum ) &amp;&amp; ( _pred_node.depth > _depth + 1 ) ) ){
						if ( !is_undefined( _pred_node.prev ) ) {
							_result.add_edge( _pred_node.prev, _succ, undefined );
						}
						
						_result.add_edge( _node, _succ, _dist );
						
						_pred_node.dist = _dist_cum;
						_pred_node.prev = _node;
						_pred_node.depth = _depth + 1;
						
						if ( !is_undefined( ds_priority_find_priority( _heap, _succ ) ) ) {
							ds_priority_change_priority( _heap, _succ, _dist_cum );
						}
					}	
				}
			}
		}
		
		ds_priority_destroy( _heap );
		
		return _result;
	}
	
	/// @member edge_create
	/// @memberof Graph
	///
	/// @desc Creates edge data
	///
	/// @arg {Any} a
	/// @arg {Any} b
	/// @arg {Edge} edge edge to be updated
	/// @arg {Number} weight
	/// @arg {Any} [attr]
	///
	/// @return {Edge}
	
	static edge_create = function( a, b, _edge, _weight ) {
		return is_undefined( _weight ) ? ( is_undefined( _edge ) ? 1 : _edge ) : _weight;
	}
	
	/// @member edge_equal
	/// @memberof Graph
	///
	/// @desc Checks if two edges are equal
	///
	/// @arg {Edge} a
	/// @arg {Edge} b
	///
	/// @return {Bool}
	
	static edge_equal = function( a, b ) {
		return ( edge_weight( a ) == edge_weight( b ) );
	}
	
	/// @member edge_copy
	/// @memberof Graph
	///
	/// @desc Copies edge data for deep copy
	///
	/// @arg {Edge} edge edge data to be copied
	///
	/// @return {Edge}
	
	static edge_copy = function( _edge ) {
		return is_struct( _edge ) ? iter( _edge ).to_struct() : _edge;
	}
	
	/// @member edge_weight
	/// @memberof Graph
	///
	/// @desc Returns edge weight
	///
	/// @arg {Edge} edge
	///
	/// @return {Number}
	
	static edge_weight = function( _edge ) {
		return _edge;
	}
	
	/// @method edges
	/// @memberof Graph
	///
	/// @desc Returns iterator for all edges in graph
	///
	/// @arg {Bool} data If true, adds edge attribute struct to yield.
	///
	/// @return {Iterator} Yields array [ a, b, [edge] ]
	
	static edges = function( ) {
		var _data = ( argument_count > 0 ) ? argument[ 0 ] : false;
		var _iter = _imap( function( _adj, _data ) {
			if ( _data ) {
				return _imap( function( _node, _edge ) {
					return [ _node, _edge[ 0 ], _edge[ 1 ] ];
				}, _repeat( _adj[ 0 ] ), _adj[ 1 ].items() );
			}
			
			return _zip( _repeat( _adj[ 0 ] ), _adj[ 1 ].keys() );
		}, adj.items(), _repeat( _data ) );
		
		return _chain_from_iterable( _iter );
	}
	
	/// @method get
	/// @memberof Graph
	///
	/// @desc Return node from Graph. If node is absent, return undefined.
	///
	/// @arg {Any} node
	///
	/// @return {Struct}
	
	static get = function( _node ) {
		return node.get( _node );
	}
	
	/// @method get_from
	/// @memberof Graph
	///
	/// @desc Returns nodes in Graph. If node is iterable, return Iterator of nodes;
	///
	/// @arg {Any} [node]
	/// @arg {bool} [data=false] If true, adds node attribute struct .
	///
	/// @return {Number}
	
	static get_from = function( ) {
		if ( argument_count > 0 ) {
			var _node = argument[ 0 ];
			var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
			
			if ( is_iterable( _node ) ) {
				var _iter = __iter_dict( iter( _node ), function( ) {
					var _result = cache;
					cache = undefined;
					return _result;
				}, function( _key ) {
					return  node.get( _key );
				}, function() {
					while ( is_undefined( cache ) &amp;&amp; ( !data.is_done() ) ) {
						cache = data.next();
						if ( is_undefined( node.get( cache ) ) ) {
							cache = undefined;
						}
					}
					
					return is_undefined( cache );
				} );
						
				_iter.node = node;
				_iter.cache = undefined;
				
				return _data ? _iter : _iter.names();
			}
			
			var _result = node.get( _node )
			return _data ? _result : ( is_undefined( _result ) ? undefined : _node );
		} else {
			return node.keys();
		}
	}
	
	/// @method get_edge
	/// @memberof Graph
	///
	/// @desc Returns edge atribute Struct associated with edge between a and b. If edge does not exist, return undefined.
	///
	/// @arg {Any} a
	/// @arg {Any} b
	///
	/// @return {Bool}
	
	static get_edge = function( a, b ) {
		return adj.get( a, b );
	}
	
	/// @method get_edges_from
	/// @memberof Graph
	///
	/// @desc Returns edges 
	///
	/// @arg {Iterable} iterable If specified, return only edges from iterable
	/// @arg {Bool} data If true, include edge data Struct in the output
	///
	/// @return {Bool}
	
	static get_edges_from = function( ) {
		if ( argument_count > 0 ) {
			var _edge = argument[ 0 ];
			var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
			
			if ( is_iterable( _edge ) ) {
				var _iter = new Iterator( iter( _edge ), function( ) {
					var _result = [ cache, cacheb ];
					if ( edge ) {
						_result[ 2 ] = adj.get( cache, cacheb );	
					}
					cache = undefined;
					return _result;
				}, function() {
					while ( is_undefined( cache ) &amp;&amp; ( !data.is_done() ) ) {
						cache = data.next();
						
						if ( is_array( cache ) ) {
							cacheb = cache[ 1 ];
							cache = cache[ 0 ];
						} else {
							cacheb = data.is_done() ? undefined : data.next();
						}
						
						if ( is_undefined( adj.get( cache, cacheb ) ) ) {
							cache = undefined;
						}
					}
					
					return is_undefined( cache );
				} );
				
				_iter.adj = adj;
				_iter.cache = undefined;
				_iter.cacheb = undefined;
				_iter.edge = _data;
				
				return _iter;
			}
			
			var _result = adj.get( _edge, _data );
			return ( ( argument_count > 2 ) ? argument[ 2 ] : false ) ? [ _edge, _data, _result ] : ( is_undefined( _result ) ? undefined : [ _edge, _data ] );
		} else {
			return edges();
		}
	}
	
	/// @method get_weight
	/// @memberof Graph
	///
	/// @desc Returns weight of edge between nodes a and b.
	///
	/// @arg {Any} a
	/// @arg {Any} b
		
	static get_weight = function( a, b ) {
		return edge_weight( get_edge( a, b ) );
	}
	
	/// @method has_edge
	/// @memberof Graph
	///
	/// @desc Returns True if the graph has edge between a and b.
	///
	/// @arg {Any} a
	/// @arg {Any} a
	///
	/// @return {Bool}
	
	static has_edge = function( a, b ) {
		if ( is_undefined( node.get( a ) ) ) {
			return false;
		}
		
		return !is_undefined( adj.get( a ).get( b ) );
	}
	
	/// @method has_node
	/// @memberof Graph
	///
	/// @desc Returns True if the graph contains the node n
	///
	/// @arg {Any} node
	///
	/// @return {Bool}
	
	static has_node = function( _node ) {
		return node.exists( _node );
	}
	
	/// @method has_path
	/// @memberof Graph
	///
	/// @desc Returns True if the graph has path between a and b.
	///
	/// @arg {Any} a
	/// @arg {Any} a
	///
	/// @return {Bool}
	
	static has_path = function( a, b ) {
		return dijkstra_from( a ).has_node( b );
	}
	
	/// @method in_degree
	/// @memberof Graph
	///
	/// @desc Returns node incoming degree in Graph. If node is iterable, return Iterator of pairs [ node, degree ];
	///
	/// @arg {Any} [node]
	///
	/// @return {Number}
	
	static in_degree = function( ) {
		if ( argument_count > 0 ) {
			var _node = argument[ 0 ];
			
			if ( is_iterable( _node ) ) {
				var _iter = __iter_dict( iter( _node ), function( ) {
					var _result = cache;
					cache = undefined;
					return _result;
				}, function( _key ) {
					return pred.get( _key ).size;
				}, function() {
					while ( is_undefined( cache ) &amp;&amp; ( !data.is_done() ) ) {
						cache = data.next();
						if ( is_undefined( pred.get( cache ) ) ) {
							cache = undefined;
						}
					}
					
					return is_undefined( cache );
				} );
						
				_iter.pred = pred;
				_iter.cache = undefined;
				
				return _iter;
			}
			
			var _adj = pred.get( _node );
			
			if ( is_undefined( _adj ) ) {
				throw "The node " + string( _node ) + " is not in the graph.";
			}
			
			return _adj.items().reduce( function( a, e ) { return a + edge_weight( e[ 1 ] ); }, 0 );
		} else {
			return number_of_nodes();	
		}
	}
	
	/// @method in_edges
	/// @memberof Graph
	///
	/// @desc Returns edges 
	///
	/// @arg {Iterable} nodes return only edges to specified nodes
	/// @arg {Bool} data If true, include edge data Struct in the output
	///
	/// @return {Bool}
	
	static in_edges = function( _nodes ) {
		var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		return get_edges_from( _chain_from_iterable( iter( get_from( _nodes ) ).map( function( _node ) {
			return _zip( pred.get( _node ).keys(), _repeat( _node ) );
		} ) ), _data );
	}
	
	/// @method is_subgraph
	/// @memberof Graph
	///
	/// @desc Returns true if graph is subgraph of supplied Graph
	///
	/// @arg {Graph} graph
	///
	/// @return {Bool}
	
	function is_subgraph( _graph ) {
		var _nodes = nodes( true );
		
		while( !_nodes.is_done( ) ) {
			var _node = _nodes.next();
			
			if ( is_undefined( _graph.get( _node[ 0 ] ) ) ) {
				return false;
			}
		}
		
		var _edges = edges( true );
		
		while( !_edges.is_done( ) ) {
			var _edge = _edges.next();
			
			if ( edge_weight( _edge[ 2 ] ) != _graph.get_weight( _edge[ 0 ], _edge[ 1 ] ) ) {
				return false;
			}
		}
		
		return true;
	}
	
	/// @method is_isomorphic
	/// @memberof Graph
	///
	/// @desc Returns true if graph is isomorphic to supplied Graph
	///
	/// @return {Bool}
	
	function is_isomorphic( _graph ) {
		return ( number_of_nodes == _graph.number_of_nodes ) &amp;&amp; ( number_of_edges == _graph.number_of_edges ) &amp;&amp; is_subgraph( _graph );
	}
	
	/// @method kruskal_mst_edges
	/// @memberof Graph
	///
	/// @desc Returns an iterator over edges in a minimum spanning forest of an undirected graph.
	///
	/// @arg {Bool} [maximum=false] Find the minimum (false) or maximum (true) spanning tree.
	/// @arg {Bool} [data=false] If True yield the edge data along with the edge.
	///
	/// @return {Iterator}
	
	static kruskal_mst_edges = function() {
		var _maximum = ( argument_count > 0 ) ? argument[ 0 ] : false;
		var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		var _iter = new Iterator( edges( true ).sorted( function( e ) { return edge_weight( e[ 2 ] ); }, _maximum ), function() {
			var _result = ext ? cache : [ cache[ 0 ], cache[ 1 ] ];
			cache = undefined;
			return _result;
		}, function() {
			while( is_undefined( cache ) &amp;&amp; ( !data.is_done() ) ) {
				cache = data.next();
				
				var a = subtrees.get( cache[ 0 ] );
				var b = subtrees.get( cache[ 1 ] );
				
				if ( ( a == b ) &amp;&amp; ( !is_undefined( a ) ) ) {
					cache = undefined;
					continue;
				}
				
				subtrees.union( cache[ 0 ], cache[ 1 ] );
			}
			
			return ( is_undefined( cache ) );
		} );
		
		_iter.subtrees = new UnionFind();
		_iter.cache = undefined;
		_iter.ext = _data;
		
		return _iter;
	}
		
	/// @method neighbors
	/// @memberof Graph
	///
	/// @desc Returns an iterator over all neighbors of node.
	///
	/// @arg {Any} node
	/// @arg {Bool} [data=false] If false only keys would be returned.
	///
	/// @return {Iterator}
	
	static neighbors = function( _node ) {
		var _adj = adj.get( _node );
		
		if ( is_undefined( _adj ) ) {
			throw "The node " + string( _node ) + " is not in the graph.";
		}
		
		var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		if ( _data ) {
			var _iter = __iter_dict( _adj.keys(), function() {
				return data.next();
			}, function( _key ) {
				return node.get( _key );
			}, function() {
				return data.is_done();
			} );
			
			_iter.node = node;
			
			return _iter;
		}
		
		return _adj.keys();
	}
	
	/// @member node_create
	/// @memberof Graph
	///
	/// @desc Creates node data
	///
	/// @arg {Any} id
	/// @arg {Node} node node to be updated
	/// @arg {Any} attr
	///
	/// @return {Node}
	
	static node_create = function( _id, _node, _attr ) {
		return is_undefined( _attr ) ? ( is_undefined( _node ) ? _id : _node ) : _attr;
	}
	
	/// @member node_copy
	/// @memberof Graph
	///
	/// @desc Copies node data for deep copy
	///
	/// @arg {Node} node node data to be copied
	///
	/// @return {Node}
	
	static node_copy = edge_copy;
	
	/// @member node_equal
	/// @memberof Graph
	///
	/// @desc Checks if two nodes are equal
	///
	/// @arg {Node} a
	/// @arg {Node} b
	///
	/// @return {Bool}
	
	static node_equal = edge_equal;
	
	/// @method nodes
	/// @memberof Graph
	///
	/// @desc Returns Iterator of nodes
	///
	/// @arg {Bool} [data=false] If false only keys would be returned.
	///
	/// @return Iterator
	
	static nodes = function( ) {
		var _data = ( argument_count > 0 ) ? argument[ 0 ] : false;
		return _data ? node.items() : node.keys();
	}
	
	/// @method number_of_edges
	/// @memberof Graph
	///
	/// @desc Returns the number of edges in the graph.
	///
	/// @return {Number}
	
	static number_of_edges = function() {
		return adj.items().reduce( function( a, e ) { return a + e[ 1 ].size; }, 0 );
	}
	
	/// @method number_of_nodes
	/// @memberof Graph
	///
	/// @desc Returns the number of nodes in the graph.
	///
	/// @return {Number}
	
	static number_of_nodes = function() {
		return node.size;
	}
	
	/// @method order
	/// @memberof Graph
	///
	/// @desc Returns the number of nodes in the graph.
	///
	/// @return {Number}
	
	static order = number_of_nodes;
	
	/// @method out_degree
	/// @memberof Graph
	///
	/// @desc Returns node outgoing degree in Graph. If node is iterable, return Iterator of pairs [ node, degree ];
	///
	/// @arg {Any} [node]
	///
	/// @return {Number}
	
	static out_degree = degree;
	
	/// @method out_edges
	/// @memberof Graph
	///
	/// @desc Returns edges 
	///
	/// @arg {Iterable} nodes return only edges from specified nodes
	/// @arg {Bool} data If true, include edge data Struct in the output
	///
	/// @return {Bool}
	
	static out_edges = function( _nodes ) {
		var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		return get_edges_from( _chain_from_iterable( iter( get_from( _nodes ) ).map( function( _node ) {
			return _zip( _repeat( _node ), adj.get( _node ).keys() );
		} ) ), _data );
	}
	
	/// @method predecessors
	/// @memberof Graph
	///
	/// @desc Returns an iterator over all predecessors of node.
	///
	/// @arg {Any} node
	/// @arg {Bool} [data=false] If false only keys would be returned.
	///
	/// @return {Iterator}
	
	static predecessors = function( _node ) {
		var _adj = pred.get( _node );
		
		if ( is_undefined( _adj ) ) {
			throw "The node " + string( _node ) + " is not in the graph.";
		}
		
		var _data = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		if ( _data ) {
			var _iter = __iter_dict( _adj.keys(), function() {
				return data.next();
			}, function( _key ) {
				return node.get( _key );
			}, function() {
				return data.is_done();
			} );
			
			_iter.node = node;
			
			return _iter;
		}
		
		return _adj.keys();
	}
	
	/// @method remove_edge
	/// @memberof Graph
	///
	/// @desc Remove the edge connection between a and b.
	///
	/// @arg {Any} a
	/// @arg {Any} b
	
	static remove_edge = function( a ) {
		var b = ( argument_count > 1 ) ? argument[ 1 ] : undefined;
		
		if ( is_array( a ) ) {
			b = a[ 1 ];
			a = a[ 0 ];
		}
		
		if ( is_undefined( adj.get( a, b ) ) ) {
			exit;
		}
		
		var _adj = adj.get( a );
		var _pred = pred.get( b );
			
		var _edge = _adj.get( b );
		
		if ( is_undefined( _edge ) ) {
			exit;	
		}
		
		_adj.remove( b );
		_pred.remove( a );
	}
	
	/// @method remove_edges_from
	/// @memberof Graph
	///
	/// @desc Remove nodes a from graph.
	///
	/// @arg {Iterable} edges
	
	static remove_edges_from = function( ) {
		if ( argument_count > 0 ) {
			var _edges = iter( argument[ 0 ] );
			while( !_edges.is_done() ) {
				var _edge = _edges.next();
				if is_array( _edge ) {
					remove_edge( _edge );	
				} else {
					if ( !_edges.is_done() ) {
						remove_edge( _edge, _edges.next() );	
					}
				}
			}
		} else {
			clear_edges();
		}
	}
	
	/// @method remove_node
	/// @memberof Graph
	///
	/// @desc Remove node a from graph.
	///
	/// @arg {Any} node
	
	static remove_node = function( _node ) {
		if ( is_undefined( node.get( _node ) ) ) {
			exit;	
		}
		
		var _adj = adj.get( _node );
		var _adj_edges = iter( _adj );
				
		while( !_adj_edges.is_done() ){
			var _edge = _adj_edges.next();
			_adj.remove( _edge[ 0 ] );
		}
			
		var _adj = pred.get( _node );
		_adj_edges = iter( _adj );
			
		while( !_adj_edges.is_done() ){
			var _edge = _adj_edges.next();
			_adj.remove( _edge[ 0 ] );
		}
				
		node.remove( _node );
	}
	
	/// @method remove_nodes_from
	/// @memberof Graph
	///
	/// @desc Remove nodes a from graph.
	///
	/// @arg {Iterable} nodes
	
	static remove_nodes_from = function( ) {
		if ( argument_count > 0 ) {
			var _nodes = iter( argument[ 0 ] );
			while( !_nodes.is_done() ) {
				remove_node( _nodes.next() );
			}
		} else {
			clear();
		}
	}
	
	/// @method reverse
	/// @memberof Graph
	///
	/// @desc Returns reversed copy of the graph
	///
	/// @arg {Bool} [deep=false] If false, node and edge data is referenced, not copied.
	///
	/// @return Graph
	
	static reverse = function() {
		var _deep = ( argument_count > 0 ) ? argument[ 0 ] : false;
		var _result = copy( _deep );
		
		var t =	_result.adj;
		_result.adj = _result.pred;
		_result.pred = t;
		
		return _result;
	}
	
	/// @method set_node_data
	/// @memberof Graph
	///
	/// @desc Set node data. Alias for add_node to avoid confusion.
	///
	/// @arg {Any} node
	/// @arg {Any} data
		
	static set_node_data = add_node;
	
	/// @method set_weight
	/// @memberof Graph
	///
	/// @desc Set weight of edge between nodes a and b.
	///
	/// @arg {Any} a
	/// @arg {Any} b
	/// @arg {Number} weight
	
	static set_weight = add_edge;
	
	/// @method shortest_path
	/// @memberof Graph
	///
	/// @desc Compute shortest path in Graph
	///
	/// @arg {Any} [source=undefined] If undefined, compute shortest paths for each possible starting node.
	/// @arg {Any} [dest] If not specified, compute shortest paths to all possible nodes.
	///
	/// @return {Array}
	
	static shortest_path = function() {
		var _source =  ( argument_count > 0 ) ? argument[ 0 ] : undefined;
		_source = iter( is_undefined( _source ) ? nodes() : _source ).to_array();
		var _dest = iter( ( argument_count > 1 ) ? argument[ 1 ] : nodes() ).to_array();
		
		var n = array_length( _dest );
		var _result = { };
		var _iter = iter( _source );
		
		if ( n == 1 ) {
			var _graph = dijkstra( _dest[ 0 ] );
						
			while( !_iter.is_done() ) {
				var _node = _iter.next();
				
				if ( _graph.has_node( _node ) ) {
					var _path = [ ];
					
					var _target = _node;
					var _depth = _graph.get( _node ).depth;
					
					for( var j = 0; j &lt;= _depth; j++ ) {
						_path[ j ] = _target;
						_target = _graph.get( _target ).succ;
					}
					
					variable_struct_set( _result, _node, _path );
				} else {
					variable_struct_set( _result, _node, undefined );
				}
			}
		} else {
			while( !_iter.is_done() ) {
				var _node = _iter.next();
				
				if ( has_node( _node ) ) {
					var _graph = dijkstra_from( _node );
					var _path = { };
					
					for( var i = 0; i &lt; n; i++ ) {
						if ( _graph.has_node( _dest[ i ] ) ) {
							var _target = _dest[ i ];
							var r = [ ];
							
							for( var j = _graph.get( _target ).depth; j >= 0; j-- ) {
								r[ j ] = _target;
								_target = _graph.get( _target ).prev;
							}
							
							variable_struct_set( _path, _dest[ i ], r );
						} else {
							variable_struct_set( _path, _dest[ i ], undefined );
						}
					}
				
					variable_struct_set( _result, _node, _path );
				} else {
					variable_struct_set( _result, _node, undefined );
				}
			}
		}
		
		if ( array_length( _source ) == 1 ) {
			_result = variable_struct_get( _result, _source[ 0 ] );
		}
		
		return _result;
	}
	
	/// @method shortest_path_length
	/// @memberof Graph
	///
	/// @desc Compute length of shortest path in Graph
	///
	/// @arg {Any} [source=undefined] If undefined, compute shortest paths length for each possible starting node.
	/// @arg {Any} [dest] If not specified, compute shortest paths length to all possible nodes.
	///
	/// @return {Array}
	
	static shortest_path_length = function() {
		var _source =  ( argument_count > 0 ) ? argument[ 0 ] : undefined;
		_source = iter( is_undefined( _source ) ? nodes() : _source ).to_array();
		var _dest = iter( ( argument_count > 1 ) ? argument[ 1 ] : nodes() ).to_array();
		
		var n = array_length( _dest );
		var _result = { };
		var _iter = iter( _source );
		
		if ( n == 1 ) {
			var _graph = dijkstra( _dest[ 0 ] );
						
			while( !_iter.is_done() ) {
				var _node = _iter.next();
				
				if ( _graph.has_node( _node ) ) {
					variable_struct_set( _result, _node, _graph.get( _node ).depth );
				} else {
					variable_struct_set( _result, _node, undefined );
				}
			}
		} else {
			while( !_iter.is_done() ) {
				var _node = _iter.next();
				
				if ( has_node( _node ) ) {
					var _graph = dijkstra_from( _node );
					var _path = { };
					
					for( var i = 0; i &lt; n; i++ ) {
						if ( _graph.has_node( _dest[ i ] ) ) {
							variable_struct_set( _path, _dest[ i ], _graph.get( _dest[ i ] ).depth );
						} else {
							variable_struct_set( _path, _dest[ i ], undefined );
						}
					}
				
					variable_struct_set( _result, _node, _path );
				} else {
					variable_struct_set( _result, _node, undefined );
				}
			}
		}
		
		if ( array_length( _source ) == 1 ) {
			_result = variable_struct_get( _result, _source[ 0 ] );
		}
		
		return _result;
	}
	
	/// @method size
	/// @memberof Graph
	///
	/// @desc Returns total of all edge weight.
	///
	/// @return {Number}
	
	static size = function() {
		var _result =  edges( true ).reduce( function( a, e ) { return a + edge_weight( e[ 2 ] ); }, 0 );
		return directed ? _result : _result / 2;
	}
	
	/// @method subgraph
	/// @memberof Graph
	///
	/// @desc Returns subgraph induced on nodes. The induced subgraph of the graph contains the nodes in interable and the edges between those nodes.
	///
	/// @arg {Iterable} nodes
	/// @arg {Bool} [copy=false]
	///
	/// @return Graph
	
	static subgraph = function( _nodes ) {
		var _result = new Graph( directed );
		var _deep = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		copy_methods( _result );
		
		_result.update_nodes( get_from( _nodes, true ), _deep );
		_result.update_edges( get_edges_from( directed ? _result.nodes().permutations( 2 ) : _result.nodes().combinations( 2 ), true ), _deep );
		
		return _result;
	}
	
	/// @method subgraph_edges
	/// @memberof Graph
	///
	/// @desc Returns subgraph induced on edges. The induced subgraph of the graph contains the edges in interable and the edges between those nodes.
	///
	/// @arg {Iterable} edges
	/// @arg {Bool} [copy=false]
	///
	/// @return Graph
	
	static subgraph_edges = function( _edges ) {
		var _result = new Graph( directed );
		var _deep = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		copy_methods( _result );
		
		_result.update_edges( get_edges_from( _edges, true ), _deep );
		_result.update_nodes( get_from( _result.nodes(), true ), _deep );
		
		return _result;
	}
	
	/// @method successors
	/// @memberof Graph
	///
	/// @desc Returns an iterator over all successors of node.
	///
	/// @arg {Any} node
	/// @arg {Bool} [data=false] If false only keys would be returned.
	///
	/// @return {Iterator}
	
	static successors = neighbors;
	
	/// @method to_directed
	/// @memberof Graph
	///
	/// @desc Returns directed copy of the graph
	///
	/// @arg {Bool} [deep=false] If false, node and edge data is referenced, not copied.
	///
	/// @return Graph
	
	static to_directed = function() {
		var _result = new Graph( true );
		var _deep = ( argument_count > 0 ) ? argument[ 0 ] : false;
		
		copy_methods( _result );
		
		_result.update_nodes( nodes( true ), _deep );
		_result.update_edges( edges( true ), _deep );
		
		return _result;
	}
	
	/// @method to_undirected
	/// @memberof Graph
	///
	/// @desc Returns undirected copy of the graph
	///
	/// @arg {Bool} [deep=false] If false, node and edge data is referenced, not copied.
	///
	/// @return Graph
	
	static to_undirected = function() {
		var _result = new Graph();
		
		copy_methods( _result );
		
		var _deep = ( argument_count > 0 ) ? argument[ 0 ] : false;
		
		_result.update_nodes( nodes( true ), _deep );
		_result.update_edges( edges( true ), _deep );
		
		return _result;
	}
	
	/// @method update
	/// @memberof Graph
	///
	/// @desc Update graph nodes and edges from another graph
	///
	/// @arg {Graph} nodes
	/// @arg {Bool} [copy=false]
	
	static update = function( _graph ) {
		var _deep = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		update_nodes( _graph.nodes( true ), _deep );		
		update_edges( _graph.edges( true ), _deep );
	}
	
	/// @method update_edges
	/// @memberof Graph
	///
	/// @desc Update the graph edges from iterable.
	///
	/// @arg {Iterable} iterable
	/// @arg {Bool} copy=false
	
	static update_edges = function( _iterable ) {
		var _edges = iter( _iterable );
		var _deep = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		if ( _deep ) {
			add_edges_from( _edges.map( function( _edge ) {
				return [ _edge[ 0 ], _edge[ 1 ], edge_copy( _edge[ 2 ] ) ];
			} ) );
		} else {
			add_edges_from( _edges );
		}
	}
	
	/// @method update_nodes
	/// @memberof Graph
	///
	/// @desc Update the graph nodes from iterable.
	///
	/// @arg {Iterable} iterable
	/// @arg {Bool} copy=false
	
	static update_nodes = function( _iterable ) {
		var _nodes = iter( _iterable );
		var _deep = ( argument_count > 1 ) ? argument[ 1 ] : false;
		
		if ( _deep ) {
			add_nodes_from( _nodes.map( function( _node ) {
				return [ _node[ 0 ], node_copy( _node[ 1 ] ) ];
			} ) );
		} else {
			add_nodes_from( _nodes );
		}
	}
}

/// @func GraphStructs( )
/// @name GraphStructs
/// @class
/// @memberof module:graphtools
///
/// @classdesc Graph with structs for nodes and edges.
///
/// @arg {Bool} [directed=false]
///
/// @return {GraphStructs} - GraphStructs struct

function GraphStructs( ) : Graph( ) constructor {
	static edge_create = function( a, b, _edge, _weight ) {
		var _attr;
		
		if ( is_array( _weight ) || is_struct( _weight ) ) {
			_attr = _weight;
			_weight = undefined;
		} else if ( argument_count > 4 ) {
			_attr = argument[ 4 ];
		}
		
		var _result = is_struct( _attr ) ? _attr : ( is_undefined( _edge ) ? { } : _edge);
		
		if ( !variable_struct_exists( _result, "weight" ) ) {
			_result.weight = is_undefined( _weight ) ? 1 : _weight;
		}
		
		var n = is_array( _attr ) ? array_length( _attr ) : 0;
		for( var i = 0; i &lt; n; i++ ) {
			variable_struct_set( _result, _attr[ i ][ 0 ], _attr[ i ][ 1 ] );
		}
		
		return _result;
	}
	
	static edge_weight = function( _edge ) {
		return _edge.weight;
	}
	
	static node_create = function( _id, _node, _attr ) {
		var _result = is_struct( _attr ) ? _attr : undefined;
		
		if ( is_undefined( _result ) ) {
			_result = is_undefined( _node ) ? { } : _node;
		}
		
		var n = is_array( _attr ) ? array_length( _attr ) : 0;
		for( var i = 0; i &lt; n; i++ ) {
			variable_struct_set( _result, _attr[ i ][ 0 ], _attr[ i ][ 1 ] );
		}
		
		return _result;
	}
}

#endregion

#region constructors

/// @func graph_complete
///
/// @desc returns graph complete graph
///
/// @arg {Iterable} [nodes=0] If integer supplied, nodes are taken from Range( n )
/// @arg {Bool} [directed=false]
///
/// @return {Graph}
///
/// @example
/// g = graph_complete( 9 );
///g.number_of_nodes() --> 9
///g.size() --> 36
/// @example
/// g = graph_complete( _irange( 11, 14 ) );
///g.number_of_nodes() --> 3
///g.nodes().sorted() --> 11, 12, 13

function graph_complete( ) {
	var _nodes = ( argument_count > 0 ) ? argument[ 0 ] : 0;
	_nodes = is_numeric( _nodes ) ? _irange( _nodes ) : iter( _nodes );
	var _directed = ( argument_count > 1 ) ? argument[ 1 ] : false;
	
	var _result = is_struct( _directed ) ? _directed : new Graph( _directed );
	_result.add_edges_from( _directed ? _nodes.permutations( 2 ) : _nodes.combinations( 2 ) );
	
	return _result;
}

/// @func graph_cycle
///
/// @desc returns cyclically connected graph
///
/// @arg {Iterable} [nodes=0] If integer supplied, nodes are taken from Range( n )
/// @arg {Bool} [directed=false]
///
/// @return {Graph}

function graph_cycle( ) {
	var _nodes = ( argument_count > 0 ) ? argument[ 0 ] : 0;
	_nodes = is_numeric( _nodes ) ? _irange( _nodes ) : iter( _nodes );
	var _directed = ( argument_count > 1 ) ? argument[ 1 ] : false;
	
	var _head = _take( 2, _nodes ).to_array();
	var _tail = _head;
	
	var _iter = _accumulate( _nodes, function( a, e ) { return [ a[ 1 ], e ]; }, _tail );
	var _result = is_struct( _directed ) ? _directed : new Graph( _directed );
	
	while( !_iter.is_done() ) {
		_tail = _iter.next();
		_result.add_edge( _tail[ 0 ], _tail[ 1 ] );
	}
	
	if ( _head != _tail ) {
		_result.add_edge( _tail[ 1 ], _head[ 0 ] );
	}
	
	return _result;
}

/// @func graph_empty
///
/// @desc returns graph with no edges
///
/// @arg {Iterable} [nodes=0] If integer supplied, nodes are taken from Range( n )
/// @arg {Bool} [directed=false]
///
/// @return {Graph}
///
/// @example
/// g = graph_empty( 10 );
///g.number_of_nodes() --> 10
///g.number_of_edges() --> 0
/// @example
/// g = graph_empty( "abc" );
///g.number_of_nodes() --> 3
///g.nodes().sorted() --> "a", "b", "c"

function graph_empty( ) {
	var _nodes = ( argument_count > 0 ) ? argument[ 0 ] : 0;
	_nodes = is_numeric( _nodes ) ? _irange( _nodes ) : iter( _nodes );
	var _directed = ( argument_count > 1 ) ? argument[ 1 ] : false;
	
	var _result = is_struct( _directed ) ? _directed : new Graph( _directed );
	_result.add_nodes_from( _nodes );
	
	return _result;
}

/// @func graph_path
///
/// @desc returns linearly connected graph
///
/// @arg {Iterable} [nodes=0] If integer supplied, nodes are taken from Range( n )
/// @arg {Bool} [directed=false]
///
/// @return {Graph}

function graph_path( ) {
	var _nodes = ( argument_count > 0 ) ? argument[ 0 ] : 0;
	_nodes = is_numeric( _nodes ) ? _irange( _nodes ) : iter( _nodes );
	var _directed = ( argument_count > 1 ) ? argument[ 1 ] : false;
	
	var _result = is_struct( _directed ) ? _directed : new Graph( _directed );
	
	_result.add_edges_from( _accumulate( _nodes, function( a, e ) { return [ a[ 1 ], e ]; }, _take( 2, _nodes ).to_array() ) );
	
	return _result;
}

/// @func graph_star
///
/// @desc returns graph where all nodes are connected to the center node
///
/// @arg {Iterable} [nodes=0] If integer supplied, nodes are taken from Range( nodes + 1 )
/// @arg {Bool} [directed=false]
///
/// @return {Graph}

function graph_star( ) {
	var _nodes = ( argument_count > 0 ) ? argument[ 0 ] : -1;
	_nodes = is_numeric( _nodes ) ? _irange( _nodes + 1 ) : iter( _nodes );
	var _directed = ( argument_count > 1 ) ? argument[ 1 ] : false;
	
	var _result = is_struct( _directed ) ? _directed : new Graph( _directed );
	
	if ( !_nodes.is_done() ) {
		var _head = _nodes.next();
		_result.add_nodes_from( _head );
		_result.add_edges_from( _zip( _repeat( _head ), _nodes ) );
	}
	
	return _result;
}

#endregion
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Wed Jul 07 2021 07:47:23 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
